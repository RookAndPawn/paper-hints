//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/kguthrie/Projects/RookAndPawn/kami-solver/kami-solver-core/src/main/java/com/rookandpawn/kami/solver/FastGraph.java
//

#include "FastGraph.h"
#include "Graph.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/System.h"

@interface ComRookandpawnKamiSolverFastGraph () {
 @public
  jint colorCount_;
  jint nodeCount_;
  jbyte *originalNodes_;
  jbyte *nodes_;
  jshort *q_;
  IOSObjectArray *edges_;
  ComRookandpawnKamiSolverGraph *g_;
  jshort *colorCounts_;
  jshort *originalColorCounts_;
  jshort startingActiveColorCount_;
  jint actualNodeCount_;
  jint qRead_;
  jint qWrite_;
  jint qCap_;
}

- (void)reset;

- (void)addToQWithShort:(jshort)n;

- (jshort)pollQ;

- (jboolean)qIsEmpty;

@end

J2OBJC_FIELD_SETTER(ComRookandpawnKamiSolverFastGraph, g_, ComRookandpawnKamiSolverGraph *)

__attribute__((unused)) static void ComRookandpawnKamiSolverFastGraph_reset(ComRookandpawnKamiSolverFastGraph *self);

__attribute__((unused)) static void ComRookandpawnKamiSolverFastGraph_addToQWithShort_(ComRookandpawnKamiSolverFastGraph *self, jshort n);

__attribute__((unused)) static jshort ComRookandpawnKamiSolverFastGraph_pollQ(ComRookandpawnKamiSolverFastGraph *self);

__attribute__((unused)) static jboolean ComRookandpawnKamiSolverFastGraph_qIsEmpty(ComRookandpawnKamiSolverFastGraph *self);

@implementation ComRookandpawnKamiSolverFastGraph

- (instancetype)initWithComRookandpawnKamiSolverGraph:(ComRookandpawnKamiSolverGraph *)g {
  ComRookandpawnKamiSolverFastGraph_initWithComRookandpawnKamiSolverGraph_(self, g);
  return self;
}

- (void)dealloc {
  if (q_) {
    free(q_);
  }
  if (nodes_) {
    free(nodes_);
  }
  if (originalNodes_) {
    free(originalNodes_);
  }
  if (colorCounts_) {
    free(colorCounts_);
  }
  if (originalColorCounts_) {
    free(originalColorCounts_);
  }
}

- (void)reset {
  ComRookandpawnKamiSolverFastGraph_reset(self);
}

- (void)addToQWithShort:(jshort)n {
  ComRookandpawnKamiSolverFastGraph_addToQWithShort_(self, n);
}

- (jshort)pollQ {
  return ComRookandpawnKamiSolverFastGraph_pollQ(self);
}

- (jboolean)qIsEmpty {
  return ComRookandpawnKamiSolverFastGraph_qIsEmpty(self);
}

- (jint)evaluateWithShort:(jshort)node
            withByteArray:(IOSByteArray *)colorSeq
                 withByte:(jbyte)finalColor {
  ComRookandpawnKamiSolverFastGraph_reset(self);
  jbyte oldColor = nodes_[node];
  jbyte prevColor = oldColor;
  jint nodesChanged;
  jint prevNodesChanges = 0;
  jbyte color;
  jint index;
  jint movesLeft = colorSeq->size_;
  jint activeColorCount = startingActiveColorCount_;
  for (index = 0; index < colorSeq->size_; index++) {
    if (movesLeft < activeColorCount - 1) {
      return index;
    }
    if (finalColor >= 0 && movesLeft == 1) {
      color = finalColor;
    }
    else {
      color = (jbyte) (1 + prevColor + IOSByteArray_Get(colorSeq, index));
    }
    if (color >= colorCount_) {
      color -= colorCount_;
    }
    if (color == prevColor && actualNodeCount_ > 1) {
      return index - 1;
    }
    ComRookandpawnKamiSolverFastGraph_addToQWithShort_(self, node);

    nodesChanged = 0;
    while (!ComRookandpawnKamiSolverFastGraph_qIsEmpty(self)) {
      jshort curr = ComRookandpawnKamiSolverFastGraph_pollQ(self);
      jbyte c = nodes_[curr];
      if (c == prevColor) {
        nodes_[curr] = color;
        nodesChanged++;
        colorCounts_[prevColor]--;
        colorCounts_[color]++;
        {
          IOSShortArray *a__ = IOSObjectArray_Get(edges_, curr);
          jshort const *b__ = ((IOSShortArray *) a__)->buffer_;
          jshort const *e__ = b__ + a__->size_;
          while (b__ < e__) {
            jshort n = *b__++;
            if (prevColor == nodes_[n]) {
              ComRookandpawnKamiSolverFastGraph_addToQWithShort_(self, n);
            }
          }
        }
      }
    }
    if (index > 0 && nodesChanged == prevNodesChanges) {
      return index - 1;
    }
    activeColorCount = 0;
    {
      for (jint b__ = 0; b__ < self->colorCount_; b__++) {
        jshort count = self->colorCounts_[b__];
        if (count > 0) {
          activeColorCount++;
        }
      }
    }
    movesLeft--;
    prevColor = color;
    prevNodesChanges = nodesChanged;
  }
  return activeColorCount == 1 ? index : index - (finalColor < 0 ? 1 : 2);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 1, 2, -1, -1, -1, -1 },
    { NULL, "S", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 3, 4, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithComRookandpawnKamiSolverGraph:);
  methods[1].selector = @selector(reset);
  methods[2].selector = @selector(addToQWithShort:);
  methods[3].selector = @selector(pollQ);
  methods[4].selector = @selector(qIsEmpty);
  methods[5].selector = @selector(evaluateWithShort:withByteArray:withByte:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "colorCount_", "I", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "nodes_", "[B", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "q_", "[S", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "edges_", "[[S", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "g_", "LComRookandpawnKamiSolverGraph;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "colorCounts_", "[S", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "originalColorCounts_", "[S", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "actualNodeCount_", "I", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "qRead_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "qWrite_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LComRookandpawnKamiSolverGraph;", "addToQ", "S", "evaluate", "S[BB" };
  static const J2ObjcClassInfo _ComRookandpawnKamiSolverFastGraph = { "FastGraph", "com.rookandpawn.kami.solver", ptrTable, methods, fields, 7, 0x1, 6, 10, -1, -1, -1, -1, -1 };
  return &_ComRookandpawnKamiSolverFastGraph;
}

@end

void ComRookandpawnKamiSolverFastGraph_initWithComRookandpawnKamiSolverGraph_(ComRookandpawnKamiSolverFastGraph *self, ComRookandpawnKamiSolverGraph *g) {
  NSObject_init(self);
  self->g_ = g;
  
  self->qCap_ = [((ComRookandpawnKamiSolverGraph *) g) getNodes]->size_ * 2;
  self->q_ = calloc(self->qCap_, sizeof(jshort));
  self->nodeCount_ = [g getNodes]->size_;
  self->nodes_ = calloc(self->nodeCount_, sizeof(jbyte));
  self->originalNodes_ = calloc(self->nodeCount_, sizeof(jbyte));
  self->edges_ = [g getEdges];
  self->colorCount_ = ((IOSObjectArray *) nil_chk([g getColors]))->size_;
  self->colorCounts_ = calloc(self->colorCount_, sizeof(jshort));
  self->originalColorCounts_ = calloc(self->colorCount_, sizeof(jshort));
  {
    IOSByteArray *a__ = [g getNodes];
    jbyte const *b__ = ((IOSByteArray *) nil_chk(a__))->buffer_;
    jbyte const *e__ = b__ + a__->size_;
    
    for (jint i = 0; i < self->colorCount_; i++) {
      self->originalColorCounts_[i] = 0;
    }
    
    jint currNode = 0;
    
    while (b__ < e__) {
      jbyte color = *b__++;
      
      self->originalNodes_[currNode++] = color;
      
      if (color >= 0) {
        (self->originalColorCounts_[color])++;
      }
    }
    
    self->startingActiveColorCount_ = 0;
    
    for (jint i = 0; i < self->colorCount_; i++) {
      if (self->colorCounts_[i] > 0) {
        self->startingActiveColorCount_++;
      }
    }
  }
  self->actualNodeCount_ = [g getActualNodeCount];
}

ComRookandpawnKamiSolverFastGraph *new_ComRookandpawnKamiSolverFastGraph_initWithComRookandpawnKamiSolverGraph_(ComRookandpawnKamiSolverGraph *g) {
  J2OBJC_NEW_IMPL(ComRookandpawnKamiSolverFastGraph, initWithComRookandpawnKamiSolverGraph_, g)
}

ComRookandpawnKamiSolverFastGraph *create_ComRookandpawnKamiSolverFastGraph_initWithComRookandpawnKamiSolverGraph_(ComRookandpawnKamiSolverGraph *g) {
  J2OBJC_CREATE_IMPL(ComRookandpawnKamiSolverFastGraph, initWithComRookandpawnKamiSolverGraph_, g)
}

void ComRookandpawnKamiSolverFastGraph_reset(ComRookandpawnKamiSolverFastGraph *self) {
  self->qRead_ = 0;
  self->qWrite_ = 0;
  
  memcpy(self->nodes_, self->originalNodes_, sizeof(jbyte) * self->nodeCount_);
  memcpy(self->colorCounts_, self->originalColorCounts_, sizeof(jshort) * self->colorCount_);
}

void ComRookandpawnKamiSolverFastGraph_addToQWithShort_(ComRookandpawnKamiSolverFastGraph *self, jshort n) {
  self->q_[self->qWrite_++] = n;
  if (self->qWrite_ >= self->qCap_) {
    self->qWrite_ = 0;
  }
}

jshort ComRookandpawnKamiSolverFastGraph_pollQ(ComRookandpawnKamiSolverFastGraph *self) {
  jshort result = self->q_[self->qRead_++];
  if (self->qRead_ >= self->qCap_) {
    self->qRead_ = 0;
  }
  return result;
}

jboolean ComRookandpawnKamiSolverFastGraph_qIsEmpty(ComRookandpawnKamiSolverFastGraph *self) {
  return self->qRead_ == self->qWrite_;
}



J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ComRookandpawnKamiSolverFastGraph)
